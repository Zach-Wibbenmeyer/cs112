Script started on Tue 17 Nov 2015 08:35:05 PM EST
zdw3@torvalds:~/workspace/cs112/project8$ ls
ArrayQueue.h	      ArrayQueueTester.h  Exception.h	 LinkedQueue.cpp  LinkedQueueTester.cpp  outputText.txt		 PalindromeDetector.h	       PalindromeDetectorTester.h  StackException.h  tester.cpp
ArrayQueueTester.cpp  Debug		  inputText.txt  LinkedQueue.h	  LinkedQueueTester.h	 PalindromeDetector.cpp  PalindromeDetectorTester.cpp  QueueException.h		   Stack.h	     typescript
zdw3@torvalds:~/workspace/cs112/project8$ cat   cat   cat ArrayQueue.h ARra    ArrayQueueTester.cpp ARra    ArrayQueueT Test    Tester.h Exception.h inputText.txt LinkedQueue.cpp LinkedQueue.h LinkedQueueTester.cpp LinkedQueueTester.h outp putText.txt PalindromeDete ctor.cc  cpp PalindromeDetector.h P PalindromeDetectorTester.cpp PalindromeDetectorTester.h QueueException.h StackException.h Stack.h test    test    tes    t  test    tester.cpp             t  tester/c  .cpp 
/* ArrayQueue.h declares a Queue class using a dynamic array.
 * Begun by: Joel Adams, for CS 112 at Calvin College.
 * Student name:
 * Date:
 * 
 * Class Invariant: 
 *    mySize == 0 ||
 *    mySize > 0 && myArray[myFirst] == getFirst()
 *               && myArray[myLast-1] == getLast().
 * 
 *  (When I am not empty:
 *     myFirst is the index of my oldest value;
 *     myLast is the index of the spot where the next
 *       item to be appended will be placed.)      
 */

#ifndef ARRAY_QUEUE_H_
#define ARRAY_QUEUE_H_

#include "QueueException.h"
#include <cstring>			//memcpy()

template <class Item>
class ArrayQueue {
public:

	ArrayQueue(const ArrayQueue<Item>& original);
	virtual ~ArrayQueue();
	ArrayQueue<Item>& operator=(const ArrayQueue<Item>& original);
	unsigned getSize() const;
	unsigned getCapacity() const;
	bool isEmpty() const;
	bool isFull() const;
	ArrayQueue(unsigned capacity);
	Item getFirst() const;
	Item getLast() const;
	void append(const Item& it);
	Item remove();
	void setCapacity(unsigned newCapacity);
protected:
	virtual void makeCopyOf(const ArrayQueue<Item>& original);
private:
	unsigned mySize;       // number of items I contain
	unsigned myCapacity;   // how many items I can store
	unsigned myFirst;      // index of oldest item (if any)
	unsigned myLast;       // index of next available spot for append (if any)
	Item*    myArray;      // dynamic array of items

	friend class ArrayQueueTester;
};

template <class Item>
ArrayQueue<Item>::ArrayQueue(const ArrayQueue<Item>& original) {
	makeCopyOf(original);
}

template <class Item>
void ArrayQueue<Item>::makeCopyOf(const ArrayQueue<Item>& original) {
	mySize = original.mySize;
	myCapacity = original.myCapacity;
	myFirst = original.myFirst;
	myLast = original.myLast;
	myArray = new Item[myCapacity];
	memcpy(myArray, original.myArray, myCapacity*sizeof(Item) );
}

template <class Item>
ArrayQueue<Item>::~ArrayQueue() {
	delete [] myArray;
	myArray = NULL;
	mySize = myFirst = myLast = 0;
}


template <class Item>
ArrayQueue<Item>& ArrayQueue<Item>::operator=(const ArrayQueue<Item>& aQueue) {
	if (this != &aQueue) {
		delete [] myArray;
		makeCopyOf(aQueue);
	}
	return *this;
}

template <class Item>
bool ArrayQueue<Item>::isEmpty() const {
	return mySize == 0;
}

template <class Item>
bool ArrayQueue<Item>::isFull() const {
	return getSize() == myCapacity;
}

template <class Item>
unsigned ArrayQueue<Item>::getCapacity() const {
	return myCapacity;
}

template <class Item>
unsigned ArrayQueue<Item>::getSize() const {
	return mySize;
}

/* Arrayqueue() Constructor - if capacity is greater than 0, set the constructor, otherwise throw
 * 			a QueueException error
 * @param: unsigned capacity
 */
template <class Item>
ArrayQueue<Item>::ArrayQueue(unsigned capacity) {
	if (capacity > 0) {
		myCapacity = capacity;
		mySize = 0;
		myFirst = 0;
		myLast = 0;
		myArray = new Item[capacity];
	}
	else {
		throw QueueException("capacity: ", "Capacity is negative");
	}
}

/* getFirst() method - returns the first item in the queue
 * @param: None
 * @return: myArray[myFirst]
 */
template <class Item>
Item ArrayQueue<Item>::getFirst() const {
	if (mySize == 0) {
		throw EmptyQueueException("Queue is empty");
	}
	else {
		return myArray[myFirst];
	}
}

/* getLast() method - returns the last item in the queue
 * @param: None
 * @return: myArray[(myLast - 1 + myCapacity) % myCapacity]
 */
template <class Item>
Item ArrayQueue<Item>::getLast() const {
	if ( isEmpty() ) {
		throw EmptyQueueException("Queue is empty");
	} else {
		return myArray[(myLast - 1 + myCapacity) % myCapacity];
	}
}

/* append() method - appends an Item to the queue
 * @param: const Item& it
 * Precondition: Queue must not be full
 * Postcondition: and item will be appended to the queue
 */
template <class Item>
void ArrayQueue<Item>::append(const Item& it) {
	if ( isFull() ) {
		throw FullQueueException("Queue is full");
	}
	else {
		myArray[myLast] = it;
		myLast = (myLast + 1) % myCapacity;
		mySize++;
	}
}

/* remove() method - removes an item from the queue
 * @param: None
 * @return: result, an unsigned variable
 * Precondition: queue must not be empty
 * Postcondition: Item will be removed from queue
 */
template <class Item>
Item ArrayQueue<Item>::remove() {
	if ( isEmpty() ) {
		throw EmptyQueueException("Queue is empty");
	}
	else {
		Item result;
		result = myArray[myFirst];
		myFirst = (myFirst + 1) % myCapacity;
		mySize--;
		return result;
	}
}

/* setCapacity() method - sets the capacity of a queue
 * @param: unsigned newCapacity
 */
template <class Item>
void ArrayQueue<Item>::setCapacity(unsigned newCapacity) {
	if (newCapacity == 0 or newCapacity < getSize() ) {
		throw QueueException("setCapacity", "new Capacity is too small");
	} else {
		Item* newArray = new Item[newCapacity];
		for (unsigned x = 0; x < mySize; x++) {
			newArray[x] = myArray[myFirst];
			myFirst = (myFirst + 1) % myCapacity;
		}

		myFirst = 0;
		myLast = mySize;
		myCapacity = newCapacity;
		myArray = newArray;
	}
}


#endif /*ARRAY_QUEUE_H_*/
/* QueueTester.cpp defines the test-methods for class Queue.
 * Joel Adams, for CS 112 at Calvin College.
 */
 
#include "ArrayQueueTester.h"
#include <iostream>
#include <cstdlib>			//exit
#include <cassert>
using namespace std;

void ArrayQueueTester::runTests() {
	cout << "Testing class ArrayQueue..." << endl;
	testConstructor();
	testAppend();
	testRemove();
	testCopyConstructor();
	testAssignment();
	cout << "All tests passed!\n" << endl;
}

void ArrayQueueTester::testAssignment() {
	cout << "- testing assignment... " << flush;
	// empty, smaller-to-bigger;
	ArrayQueue<char> q1(4);
	ArrayQueue<char> q2(3);
	q1 = q2;
	assert( q1.isEmpty() );
	assert( q1.myCapacity == 3 );
	assert( q1.getSize() == 0 );
	assert( q1.myFirst == q2.myFirst );
	assert( q1.myLast == q2.myLast );
	assert( q1.myArray != q2.myArray );
	cout << " 1 " << flush;
	//empty, bigger to smaller
	ArrayQueue<char> q3(3);
	ArrayQueue<char> q4(4);
	q3 = q4;
	assert( q3.isEmpty() );
	assert( q3.myCapacity == 4 );
	assert( q3.getSize() == 0 );
	assert( q3.myFirst == q4.myFirst );
	assert( q3.myLast == q4.myLast );
	assert( q3.myArray != q4.myArray );
	cout << " 2 " << flush;
	// full, same-sized
	ArrayQueue<char> q5(4);
	q5.append(11);
	q5.append(22);
	q5.append(33);
	q5.append(44);
	ArrayQueue<char> q6(4);
	q6 = q5;
	assert( q6.isFull() );
	assert( !q6.isEmpty() );
	assert( q6.myCapacity == 4 );
	assert( q6.getSize() == 4 );
	assert( q6.myFirst == q5.myFirst );
	assert( q6.myLast == q5.myLast );
	for (unsigned i = 0; i < q6.myCapacity; i++) {
		assert( q6.myArray[i] == q5.myArray[i] );
	}
	assert( q6.myArray != q5.myArray );
	cout << " 3 " << flush;
	// full, smaller-to-larger
	ArrayQueue<char> q7(3);
	q7 = q5;
	assert( q7.isFull() );
	assert( !q7.isEmpty() );
	assert( q7.myCapacity == 4 );
	assert( q7.getSize() == 4 );
	assert( q7.myFirst == q5.myFirst );
	assert( q7.myLast == q5.myLast );
	for (unsigned i = 0; i < q7.myCapacity; i++) {
		assert( q7.myArray[i] == q5.myArray[i] );
	}
	assert( q7.myArray != q5.myArray );
	cout << " 4 " << flush;
	// full, larger-to-smaller
	ArrayQueue<char> q8(5);
	q8 = q5;
	assert( q8.isFull() );
	assert( !q8.isEmpty() );
	assert( q8.myCapacity == 4 );
	assert( q8.getSize() == 4 );
	assert( q8.myFirst == q5.myFirst );
	assert( q8.myLast == q5.myLast );
	for (unsigned i = 0; i < q8.myCapacity; i++) {
		assert( q8.myArray[i] == q5.myArray[i] );
	}
	assert( q8.myArray != q5.myArray );
	cout << " 5 " << flush;
	// self assignment
	q5 = q5;
	assert( q5.isFull() );
	assert( !q5.isEmpty() );
	assert( q5.myCapacity == 4 );
	assert( q5.getSize() == 4 );
	assert( q5.myArray[0] == 11 );
	assert( q5.myArray[1] == 22 );
	assert( q5.myArray[2] == 33 );
	assert( q5.myArray[3] == 44 );
	cout << " 6 " << flush;
	// chaining
	q1 = q3 = q5;
	assert( q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.myCapacity == 4 );
	assert( q1.getSize() == 4 );
	assert( q1.myArray[0] == 11 );
	assert( q1.myArray[1] == 22 );
	assert( q1.myArray[2] == 33 );
	assert( q1.myArray[3] == 44 );
	assert( q1.myArray != q3.myArray );
	assert( q1.myArray != q5.myArray );
	assert( q3.myArray != q5.myArray );
	cout << " 7 " << flush;
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testCopyConstructor() {
	cout << "- testing copy constructor... " << flush;
	// empty queue
	ArrayQueue<char> q1(4);
	ArrayQueue<char> q2(q1);
	assert( q2.isEmpty() );
	assert( !q2.isFull() );
	assert( q2.myCapacity == q1.myCapacity);
	assert( q2.myFirst == q1.myFirst );
	assert( q2.myLast == q1.myLast );
	assert( q2.myArray != q1.myArray );
	cout << " 1 " << flush;
	// queue of 1 item
	ArrayQueue<char> q3(4);
	q3.append(11);
	ArrayQueue<char> q4(q3);
	assert( !q4.isFull() );
	assert( !q4.isEmpty() );
	assert( q4.myCapacity == q3.myCapacity);
	assert( q4.myFirst == q3.myFirst );
	assert( q4.myLast == q3.myLast );
	assert( q4.myArray != q3.myArray );
	assert( q4.getFirst() == 11 );
	assert( q4.getLast() == 11 );
	assert( q4.myArray != q3.myArray );
 	cout << " 2 " << flush;
 	// full queue
 	q3.append(22);
 	q3.append(33);
 	q3.append(44);
 	ArrayQueue<char> q5(q3);
	assert( q5.isFull() );
	assert( !q5.isEmpty() );
	assert( q5.myCapacity == q3.myCapacity);
	assert( q5.myFirst == q3.myFirst );
	assert( q5.myLast == q3.myLast );
	assert( q5.myArray != q3.myArray );
 	assert( q5.getFirst() == 11 );
	assert( q5.getLast() == 44 );
	assert( q5.myArray != q3.myArray );
 	cout << " 3 " << flush;
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testRemove() {
	cout << "- testing remove()... " << flush;
	ArrayQueue<int> q1(4);
	cout << " 0 " << flush;
	// check with empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 1\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 1 " << flush;
	}
	// check with 1 item
	q1.append(1);
	assert( !q1.isEmpty() );
	assert( q1.remove() == 1 );
	assert( q1.isEmpty() );
	cout << " 2 " << flush;
	// check with 2 items
	q1.append(11);
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 11 );
	assert( q1.getFirst() == 22 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 22 );
	assert( q1.isEmpty() );
	cout << " 3 " << flush;
	// load it up
	q1.append(111);
	q1.append(222);
	q1.append(333);
	q1.append(444);
	assert( q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 111 );
	assert( q1.getLast() == 444 );
	// start removing items
	assert( q1.remove() == 111 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 222 );
	assert( q1.getLast() == 444 );
    cout << " 4a " << flush;
	assert( q1.remove() == 222 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 333 );
	assert( q1.getLast() == 444 );
    cout << " 4b " << flush;
	assert( q1.remove() == 333 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 444 );
	assert( q1.getLast() == 444 );
    cout << " 4c " << flush;
	assert( q1.remove() == 444 );
	assert( !q1.isFull() );
	assert( q1.isEmpty() );
    cout << " 4d " << flush;
	// recheck empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 2\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 5 " << flush;
	}
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testAppend() {
	cout << "- testing append(), getFirst(), getLast() ... " << flush;
	ArrayQueue<int> q1(4);
	assert( q1.isEmpty() );
	assert( !q1.isFull() );
	try {
		q1.getFirst();
		cerr << "\ngetFirst() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0a " << flush;
	}
	try {
		q1.getLast();
		cerr << "\ngetLast() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0b " << flush;
	}
	q1.append(11);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 11 );
	cout << " 1 " << flush;
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	cout << " 2 " << flush;
	q1.append(33);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 33 );
	cout << " 3 " << flush;
	q1.append(44);
	assert( !q1.isEmpty() );
	assert( q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 44 );
	cout << " 4 " << flush;
	// append to full queue
	try {
		q1.append(55);
		cerr << "\nappend() worked on full queue\n";
		exit(1);
	} catch (FullQueueException& fqe) {
		cout << " 5 " << flush;
	}
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testConstructor() {
	cout << "- testing constructor... " << flush;
	// try with capacity zero
	try {
		ArrayQueue<char> q1(0);
		cerr << "Constructed Queue with capacity zero" << endl;
		exit(1);
	} catch (QueueException& qe) {
	    cout << " 1 " << flush;
	}

	// positive capacity
	ArrayQueue<char> q2(3);
	assert( q2.isEmpty() );
	assert( !q2.isFull() );
	assert( q2.myCapacity == 3 );
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}

/* ArrayQueueTester.h declares the class that tests class ArrayQueue.
 * Joel Adams, for CS 112 at Calvin College.
 */
 
#ifndef QUEUETESTER_H_
#define QUEUETESTER_H_

#include "ArrayQueue.h"

class ArrayQueueTester {
public:
	void runTests();
	void testConstructor();
	void testAppend();
	void testRemove();
	void testCopyConstructor();
	void testAssignment();
};

#endif /*QUEUETESTER_H_*/
/* Exception.h defines a class to consolidate the functionality
 *  that different kinds of exceptions have in common.
 * Joel Adams, for CS 112 at Calvin College.
 */

#ifndef EXCEPTION_H_
#define EXCEPTION_H_

#include <string>    // string
#include <iostream>  // ostream
using namespace std;

class Exception {
public:
   /* construct an Exception
    * Parameters: whereThrown, a string naming the method that threw me.
    *              message, a description of the problem.
    */
   Exception(const string& whereThrown, const string& message) { 
      myLocation = whereThrown; 
      myMessage = message; 
   }
   
   virtual ~Exception() {}
   
   /* build a string representation of myself
    * (polymorphic, in case you want to override it)
    */
   virtual string asString() const { 
   	  return "*** " + className() + " in " + myLocation + ": "
                  + myMessage; 
   }
   
   /* polymorphic method to retrieve the name of the class
    *  (used by asString() above)
    */
   virtual string className() const {
   	  return "Exception";
   }

private:
   string myLocation;    // the method where I was thrown
   string myMessage;     // a description of the problem
};  // Exception

/* insert an Exception (or its subclass) into an ostream
 * Parameters: out, an ostream;
 *             e, an Exception.
 * Postcondition: out contains e's string representation
 *               && out is the return-value.
 */
inline ostream& operator<<(ostream& out, const Exception& e) {
	out << e.asString();
	return out;
}
      
#endif /*EXCEPTION_H_*/

Drawn Onward

by Felicia Lamport
extended by Joel Adams        

The learned men of Rome
could turn a palindrome
but they were not the first.

For Adam, says the myth,
began conversing with
a sentence that reversed:
"Madam, I'm Adam"
seemed
a phrase to be esteemed
the moment it was popped.
But that was not to be
- his lady instantly said
"Eve"
which left it topped.

Eve damned Eden; mad Eve
bore two sons,
as goes the fable,
the first named
Cain, a maniac,
who slew his brother Able.
He lived as a devil, eh?
Violence begat violence, until today
we panic in a pew,
the cycle turns anew
and descendents of Ned Ludd
-- dumb mobs -- bomb mud.

Asked his favorite dessert, Archimedes said,
"I prefer PI"

And Napoleon, post-Josephine, mused,
"Able was I, ere I saw Elba,"
as he met his Waterloo, confused.

Anonymous, the most
prolific bard, can boast
of being host
to these:

"Was it a car or a cat I saw ?"

"Some men interpret nine memos."

"Lewd did I live, evil I did dwel."

"Sex at noon taxes."

"A man, a plan, a canal, Panama !"

"Stop, murder us not, tonsured rumpots !"

"Straw? No, too stupid a fad. I put soot on warts."

"Doc, note: I dissent. A fast never prevents a fatness. I diet on cod."

"Kay, a red nude, peeped under a yak."

and that marvel of marvels:

"Sit on a potato pan, Otis !"

What span, what palindromic bliss !
I've wrung the alphabet
repeatedly to get
a Janus-phrase so spry
at backwards somersaults.
But as each hope turns false,
in words, alas, drown I.
/* LinkedQueue.cpp defines the methods for class LinkedQueue.
 * Joel Adams, for CS 112 at Calvin College.
 * Student name:
 * Date:
 */

#include "LinkedQueue.h"


LinkedQueue::LinkedQueue(const LinkedQueue& original) {
	makeCopyOf(original);
}

void LinkedQueue::makeCopyOf(const LinkedQueue& original) {
	mySize = original.mySize;
	if ( mySize == 0 ) {
		myFirst = myLast = NULL;
	} else {
		myFirst = new Node(original.getFirst(), NULL);
		Node * temp0 = original.myFirst->myNext;
		Node * temp1 = myFirst;
		while (temp0 != NULL) {
			temp1->myNext = new Node(temp0->myItem, NULL);
			temp1 = temp1->myNext;
			temp0 = temp0->myNext;
		}
		myLast = temp1;
	}
}

LinkedQueue::~LinkedQueue() {
	delete myFirst;
	myFirst = myLast = NULL;
	mySize = 0;
}

LinkedQueue& LinkedQueue::operator=(const LinkedQueue& aQueue) {
	if (this != &aQueue) {
		delete myFirst;    // invokes recursive ~Node()
		makeCopyOf(aQueue);
	}
	return *this;
}

/* LinkedQueue() Constructor
 * @param: None
 * @return: Nothing
 */
LinkedQueue::LinkedQueue() {
	mySize = 0;
	myFirst = NULL;
	myLast = NULL;
}

/* getFirst() method - gets the first item of the queue
 * @param: None
 * @return: myFirst->myItem
 * Precondition: Queue must not be empty
 * Postcondition: The first item will be returned
 */
Item LinkedQueue::getFirst() const {
	if ( isEmpty() ) {
		throw EmptyQueueException("Queue is empty");
	}
	else {
		return myFirst -> myItem;
	}
}

/* getLast() method - returns the last item of the queue
 * @param: None
 * @return: myLast->myItem
 * Precondition: Queue must not be empty
 * Postcondition: the last item of the queue will be returned
 */
Item LinkedQueue::getLast() const {
	if ( isEmpty() ) {
		throw EmptyQueueException("Queue is empty");
	}
	else {
		return myLast -> myItem;
	}
}

/* append() method - appends an item to the queue
 * @param: const Item& it
 * @return: Nothing
 */
void LinkedQueue::append(const Item& it) {
	try {
		Node* nPtr = new Node(it, NULL);
		if ( isEmpty() ) {
			myFirst = nPtr;
		} else {
			myLast -> myNext = nPtr;
		}
		myLast = nPtr;
		mySize++;
	} catch (bad_alloc& ba) {
		throw FullQueueException("Queue is full");
	}
}

/* remove() method - removes an item from the queue
 * @param: None
 * @return: result, an Item
 * Precondition: The queue must not be empty
 * Postcondition: An item will be removed from the queue
 */
Item LinkedQueue::remove() {
	if ( isEmpty() ) {
		throw EmptyQueueException("Queue is empty");
	} else {
		Item result;
		result = myFirst -> myItem;
		Node* nPtr = myFirst;
		myFirst = myFirst -> myNext;
		nPtr -> myNext = NULL;
		delete nPtr;
		mySize--;
		return result;
	}
}


/* LinkedQueue.h declares a Queue class using linked nodes.
 * Begun by: Joel Adams, for CS 112 at Calvin College.
 * Student name:
 * Date:
 * 
 * Class Invariant: 
 *    mySize == 0 && myFirst == NULL && myLast == NULL ||
 *    mySize > 0 && myFirst == the address of a node containing the oldest item
 *               && myLast == the address of a node containing the newest item.
 */

#ifndef LINKED_QUEUE_H_
#define LINKED_QUEUE_H_

#include "QueueException.h"

typedef int Item;

class LinkedQueue {
public:

	LinkedQueue(const LinkedQueue& original);
	virtual ~LinkedQueue();
	LinkedQueue& operator=(const LinkedQueue& original);
	unsigned getSize() const { return mySize; }
	bool isEmpty() const { return mySize == 0; }
	bool isFull() const { return false; }
	LinkedQueue();
	Item getFirst() const;
	Item getLast() const;
	void append(const Item& it);
	Item remove();

protected:
	void makeCopyOf(const LinkedQueue& original);
private:
	unsigned mySize;
	struct Node {
		Item myItem;
		Node* myNext;
		
		Node(const Item& it, Node* next) { myItem = it; myNext = next; }
		~Node() { delete myNext; }
	};
	Node * myFirst;
	Node * myLast;
	friend class LinkedQueueTester;
};

#endif /*LINKED_QUEUE_H_*/
#include "LinkedQueueTester.h"
#include <iostream>
#include <cassert>
#include <cstdlib>
using namespace std;

void LinkedQueueTester::runTests() {
	cout << "Testing class LinkedQueue..." << endl;
	testConstructor();
	testAppend();
	testRemove();
	testCopyConstructor();
	testAssignment();
	cout << "All tests passed!\n" << endl;
}

void LinkedQueueTester::testAssignment() {
	cout << "- testing assignment... " << flush;
	// empty-to-empty;
	LinkedQueue q1;
	LinkedQueue q2;
	q1 = q2;
	assert( q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getSize() == 0 );
	assert( q1.myFirst == NULL );
	assert( q1.myLast == NULL );
	cout << " 1 " << flush;
	//non-empty to empty
	LinkedQueue q3;
	LinkedQueue q4;
	q4.append(11);
	q4.append(22);
	q4.append(33);
	q3 = q4;
	assert( !q3.isEmpty() );
	assert( !q3.isFull() );
	assert( q3.getSize() == 3 );
	assert( q3.getFirst() == q4.getFirst() );
	assert( q3.getLast() == q4.getLast() );
	assert( q3.myFirst != q4.myFirst );
	assert( q3.myLast != q4.myLast );
	cout << " 2 " << flush;
	// empty to non-empty
	LinkedQueue q5;
	q5.append(11);
	q5.append(22);
	q5.append(33);
	q5.append(44);
	LinkedQueue q6;
	q5 = q6;
	assert( !q5.isFull() );
	assert( q5.isEmpty() );
	assert( q5.getSize() == 0 );
	assert( q5.myFirst == NULL );
	assert( q5.myLast == NULL );
	cout << " 3 " << flush;
	// both non-empty, larger-to-smaller
	LinkedQueue q7;
	q7.append(11);
	LinkedQueue q8;
	q8.append(22);
	q8.append(33);
	q8.append(44);
	q7 = q8;
	assert( !q7.isFull() );
	assert( !q7.isEmpty() );
	assert( q7.getSize() == 3 );
	assert( q7.myFirst != q8.myFirst );
	assert( q7.myLast != q8.myLast );
	assert( q7.getFirst() == q8.getFirst() );
	assert( q7.getLast() == q8.getLast() );
	cout << " 4 " << flush;
	// both non-empty, smaller-to-larger
	LinkedQueue q9;
	q9.append(55);
	q9.append(66);
	q7 = q9;
	assert( !q7.isFull() );
	assert( !q7.isEmpty() );
	assert( q7.getSize() == 2 );
	assert( q7.myFirst != q9.myFirst );
	assert( q7.myLast != q9.myLast );
	assert( q7.getFirst() == q9.getFirst() );
	assert( q7.getLast() == q9.getLast() );
	cout << " 5 " << flush;
	// self assignment
	q8 = q8;
	assert( !q8.isFull() );
	assert( !q8.isEmpty() );
	assert( q8.getSize() == 3 );
	assert( q8.getFirst() == 22 );
	assert( q8.myFirst->myNext->myItem == 33 );
	assert( q8.getLast() == 44 );
	cout << " 6 " << flush;
	// chaining
	q1 = q5 = q8;
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getSize() == 3 );
	assert( q1.getFirst() == 22 );
	assert( q1.myFirst->myNext->myItem == 33 );
	assert( q1.getLast() == 44 );
	assert( q1.myFirst != q5.myFirst );
	assert( q1.myFirst != q8.myFirst );
	assert( q5.myFirst != q8.myFirst );
	assert( q1.myLast != q5.myLast );
	assert( q1.myLast != q8.myLast );
	assert( q5.myLast != q8.myLast );
	cout << " 7 " << flush;
	cout << "Passed!" << endl;
}

void LinkedQueueTester::testCopyConstructor() {
	cout << "- testing copy constructor... " << flush;
	// empty queue
	LinkedQueue q1;
	LinkedQueue q2(q1);
	assert( q2.isEmpty() );
	assert( !q2.isFull() );
	assert( q2.myFirst == NULL );
	assert( q2.myLast == NULL );
	assert( q2.getSize() == 0 );
	cout << " 1 " << flush;
	// queue of 3 items
	LinkedQueue q3;
	q3.append(11);
	q3.append(22);
	q3.append(33);
	LinkedQueue q4(q3);
	assert( !q4.isFull() );
	assert( !q4.isEmpty() );
	assert( q4.myFirst != q3.myFirst );
	assert( q4.myLast != q3.myLast );
	assert( q4.getFirst() == 11 );
	assert( q4.myFirst->myNext->myItem == 22 );
	assert( q4.getLast() == 33 );
	assert( q4.getSize() == 3 );
	assert( q4.myFirst != q3.myFirst );
	assert( q4.myLast != q3.myLast );
 	cout << " 2 " << flush;
	cout << "Passed!" << endl;
}

void LinkedQueueTester::testRemove() {
	cout << "- testing remove()... " << flush;
	LinkedQueue q1;
	cout << " 0 " << flush;
	// check with empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 1\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 1 " << flush;
	}
	// check with 1 item
	q1.append(1);
	assert( !q1.isEmpty() );
	assert( q1.remove() == 1 );
	assert( q1.isEmpty() );
	cout << " 2 " << flush;
	// check with 2 items
	q1.append(11);
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 11 );
	assert( q1.getFirst() == 22 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 22 );
	assert( q1.isEmpty() );
	cout << " 3 " << flush;
	// try several values
	q1.append(111);
	q1.append(222);
	q1.append(333);
	q1.append(444);
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 111 );
	assert( q1.getLast() == 444 );
	// now start removing them
	assert( q1.remove() == 111 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 222 );
	assert( q1.getLast() == 444 );
    cout << " 4a " << flush;
	assert( q1.remove() == 222 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 333 );
	assert( q1.getLast() == 444 );
    cout << " 4b " << flush;
	assert( q1.remove() == 333 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 444 );
	assert( q1.getLast() == 444 );
    cout << " 4c " << flush;
	assert( q1.remove() == 444 );
	assert( !q1.isFull() );
	assert( q1.isEmpty() );
    cout << " 4d " << flush;
	// recheck with empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 2\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 5 " << flush;
	}
	cout << "Passed!" << endl;
}

void LinkedQueueTester::testAppend() {
	cout << "- testing append(), getFirst(), getLast(), ... " << flush;
	LinkedQueue q1;
	assert( q1.isEmpty() );
	assert( !q1.isFull() );
	try {
		q1.getFirst();
		cerr << "\ngetFirst() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0a " << flush;
	}
	try {
		q1.getLast();
		cerr << "\ngetLast() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0b " << flush;
	}
	q1.append(11);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 11 );
	cout << " 1 " << flush;
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	cout << " 2 " << flush;
	q1.append(33);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 33 );
	cout << " 3 " << flush;
	q1.append(44);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 44 );
	cout << " 4 " << flush;
	cout << "Passed!" << endl;
}

void LinkedQueueTester::testConstructor() {
	cout << "- testing constructor... " << flush;
	// linked queues have no capacity
	LinkedQueue q1;
	assert( q1.getSize() == 0 );
	assert( q1.myFirst == NULL );
	assert( q1.myLast == NULL );
 	cout << " Passed!" << endl;
}

#ifndef LINKEDQUEUETESTER_H_
#define LINKEDQUEUETESTER_H_

#include "LinkedQueue.h"

class LinkedQueueTester {
public:
	void runTests();
	void testConstructor();
	void testAppend();
	void testRemove();
	void testCopyConstructor();
	void testAssignment();
};

#endif /*LINKEDQUEUETESTER_H_*/
Drawn Onward  ***
 
by Felicia Lamport 
extended by Joel Adams         
 
The learned men of Rome 
could turn a palindrome 
but they were not the first. 
 
For Adam, says the myth, 
began conversing with 
a sentence that reversed: 
"Madam, I'm Adam"  ***
seemed 
a phrase to be esteemed 
the moment it was popped. 
But that was not to be 
- his lady instantly said 
"Eve"  ***
which left it topped. 
 
Eve damned Eden; mad Eve  ***
bore two sons, 
as goes the fable, 
the first named 
Cain, a maniac,  ***
who slew his brother Able. 
He lived as a devil, eh?  ***
Violence begat violence, until today 
we panic in a pew,  ***
the cycle turns anew 
and descendents of Ned Ludd 
-- dumb mobs -- bomb mud.  ***
 
Asked his favorite dessert, Archimedes said, 
"I prefer PI"  ***
 
And Napoleon, post-Josephine, mused, 
"Able was I, ere I saw Elba,"  ***
as he met his Waterloo, confused. 
 
Anonymous, the most 
prolific bard, can boast 
of being host 
to these: 
 
"Was it a car or a cat I saw ?"  ***
 
"Some men interpret nine memos."  ***
 
"Lewd did I live, evil I did dwel."  ***
 
"Sex at noon taxes."  ***
 
"A man, a plan, a canal, Panama !"  ***
 
"Stop, murder us not, tonsured rumpots !"  ***
 
"Straw? No, too stupid a fad. I put soot on warts."  ***
 
"Doc, note: I dissent. A fast never prevents a fatness. I diet on cod."  ***
 
"Kay, a red nude, peeped under a yak."  ***
 
and that marvel of marvels: 
 
"Sit on a potato pan, Otis !"  ***
 
What span, what palindromic bliss ! 
I've wrung the alphabet 
repeatedly to get 
a Janus-phrase so spry 
at backwards somersaults. 
But as each hope turns false, 
in words, alas, drown I.  ***
 
/*
 * PalindromeDetector.cpp
 *
 *  Created on: Nov 17, 2015
 *      Author: zdw3
 */

#include "PalindromeDetector.h"

/*
 * Detects the palindromes
 */
bool PalindromeDetector::isPalindrome(string& str) {
	str = str + " ";
	stringstream ss(str);
	char c;
	Stack<char> s1(1);
	ArrayQueue<char> q1(1);
	while (ss) {
		ss.get(c);
		if ( isupper(c) ) {
			c = tolower(c);
		}
		if ( isalpha(c) ) {
			try {
				s1.push(c);
				q1.append(c);
			} catch (StackException& se) {
				s1.setCapacity(s1.getCapacity() * 2);
				s1.push(c);
				q1.setCapacity(q1.getCapacity() * 2);
				q1.append(c);
			}
		}
	}
	if ( s1.getSize() == 0 ) {
		return false;
	}
	while (!s1.isEmpty() ) {
		char ch1 = s1.pop();
		char ch2 = q1.remove();
		if (ch1 != ch2) {
			return false;
		}
	}
	return true;
}


/*
 * Detects the palindromes in a string and returns ***
 */
void PalindromeDetector::detectPalindromes() {
	ifstream fin(myInputFile.c_str() );
	ofstream fout(myOutputFile.c_str() );
	assert( fin.is_open() );
	assert( fout.is_open() );
	while (fin) {
		string s;
		getline(fin, s);
		if ( isPalindrome(s) ) {
			s = s + " ***";
		}
		fout << s << endl;
	}
	fin.close();
	fout.close();
}

/*
 * Explicit Value constructor
 */
PalindromeDetector::PalindromeDetector(const string& inputFile, const string& outputFile) {
	myInputFile = inputFile;
	myOutputFile = outputFile;
}
/*
 * PalindromeDetector.h
 *
 *  Created on: Nov 17, 2015
 *      Author: zdw3
 */

#ifndef PALINDROMEDETECTOR_H_
#define PALINDROMEDETECTOR_H_

//Include the necessary libraries
#include "Stack.h"
#include "ArrayQueue.h"
#include "StackException.h"
#include <iostream>
#include <cctype>
#include <sstream>
#include <fstream>
#include <cassert>
#include <string>
using namespace std;

//Create a class for the PalindromeDetector
class PalindromeDetector {
public:
	bool isPalindrome(string& str);
	void detectPalindromes();
	PalindromeDetector(const string& inputFile, const string& outputFile);
private:
	string myInputFile;
	string myOutputFile;
	friend class PalindromeDetectorTester;
};

#endif /* PALINDROMEDETECTOR_H_ */
/*
 * PalindromeDetectorTester.cpp
 *
 *  Created on: Nov 17, 2015
 *      Author: zdw3
 */

#include "PalindromeDetectorTester.h"

void PalindromeDetectorTester::runTests() const {
	cout << "Testing PalindromeDetector class... " << endl;
	testConstructors();
	testIsPalindrome();
	testDetectPalindromes();
	cout << "All tests passed! " << endl;
}

void PalindromeDetectorTester::testConstructors() const {
	cout << "Testing constructors... " << flush;
	string s1 = "testFile1.txt";
	string s2 = "testFile2.txt";
	PalindromeDetector p1(s1, s2);
	assert(p1.myInputFile == s1);
	assert(p1.myOutputFile == s2);
	cout << " Passed! " << endl;
}


void PalindromeDetectorTester::testIsPalindrome() const {
	cout << "Testing isPalindrome method... " << flush;
	string s1 = "testFile1.txt";
	string s2 = "testFile2.txt";
	PalindromeDetector p1(s1, s2);
	string s3 = " ";
	assert(!p1.isPalindrome(s3));
	cout << " 1 " << flush;
	string s4 = "z";
	assert(p1.isPalindrome(s4));
	cout << " 2 " << flush;
	string s5 = "za";
	assert(!p1.isPalindrome(s5));
	cout << " 3 " << flush;
	string s6 = "zz";
	assert(p1.isPalindrome(s6));
	cout << " 4 " << flush;
	string s7 = "racecar";
	assert(p1.isPalindrome(s7));
	cout << " 5 " << flush;
	string s8 = "fda...''dasf;;;";
	assert(!p1.isPalindrome(s8));
	cout << " 6 " << flush;
	string s9 = "A man, a plan, a canal, Panama";
	assert(p1.isPalindrome(s9));
	cout << " 7 " << flush;
	cout << " Passed! " << endl;
}

void PalindromeDetectorTester::testDetectPalindromes() const {
	cout << "Testing detectPalindromes method... " << flush;
	string s1 = "inputText.txt";
	string s2 = "outputText.txt";
	PalindromeDetector p1(s1, s2);
	p1.detectPalindromes();
	cout << " Passed! " << endl;
}
/*
 * PalindromeDetectorTester.h
 *
 *  Created on: Nov 17, 2015
 *      Author: zdw3
 */

#ifndef PALINDROMEDETECTORTESTER_H_
#define PALINDROMEDETECTORTESTER_H_

#include "PalindromeDetector.h"
#include <iostream>
#include <cassert>
using namespace std;

class PalindromeDetectorTester {
public:
	void runTests() const;
	void testConstructors() const;
	void testIsPalindrome() const;
	void testDetectPalindromes() const;
};

#endif /* PALINDROMEDETECTORTESTER_H_ */
/* QueueException.h provides a simple exception class for Queues to throw,
 *   plus subclasses (EmptyQueueException, FullQueueException)
 *   for more fine-grained error-handling.
 * See Exception.h for its superclass.
 * Joel Adams, for CS 112 at Calvin College.
 */
 
#ifndef QUEUEEXCEPTION_H_
#define QUEUEEXCEPTION_H_

#include "Exception.h"

class QueueException : public Exception {
public:
   QueueException(const string& whereThrown, const string& message)
   : Exception(whereThrown, message)
   {}
   
   virtual string className() const {
   	 return "QueueException";
   }
};

class EmptyQueueException : public QueueException {
public:
   EmptyQueueException(const string& whereThrown)
    : QueueException(whereThrown, "queue is empty")
   {}
   
   virtual string className() const {
   	  return "EmptyQueueException";
   }
};

class FullQueueException : public QueueException {
public:
   FullQueueException(const string& whereThrown)
    : QueueException(whereThrown, "queue is full")
   {}
   
   virtual string className() const {
   	  return "FullQueueException";
   }
};


#endif /*QUEUEEXCEPTION_H_*/

/* StackException.h models exceptions in stack operations.
 * Joel Adams, for CS 112 at Calvin College.
 * Student Name: Zach Wibbenmeyer
 * Date: July 23, 2015
 */

#ifndef STACK_EXCEPTION
#define STACK_EXCEPTION

#include <iostream>
using namespace std;

 
class StackException {
public:
   StackException(const string& whereThrown,
                  const string& message) { 
       myLocation = whereThrown; 
       myMessage = message; 
   }

   string asString() const {
       return "*** StackException in " +
               myLocation + ": " + myMessage; 
   }

private:
   string myLocation;
   string myMessage;
};  // StackException


/* Function to allow a StackException (or a subclass) to be displayed
 * via an ostream.
 * Parameters: out, an ostream;
 *             se, a StackException.
 * Postcondition: the string representation of se has been inserted
 * into out
 *             && return-value == out.
 */
inline ostream& operator<<(ostream& out, const StackException& se) {
      out << se.asString();
      return out;
}

#endif

/* Stack.h provides a (dynamic-array-based) Stack class.
 * Joel Adams, for CS 112 at Calvin College.
 * Student Name: Zach Wibbenmeyer
 * Date: July 23, 2015
 * 
 * Invariant: myTop == 0 && isEmpty() && !isFull()
 *         || myTop == myCapacity && !isEmpty() && isFull()
 *         || myTop > 0 && myTop < myCapacity && !isEmpty() && !isFull().
 * Notes: 
 * 1. Member myTop always contains the index of the next empty space in myArray
 *        (the index of the array element into which the next pushed item will be placed).
 * 2. Sending push() to a full Stack throws the exception Stack::Overflow.
 * 3. Sending pop() or getTop() to an empty Stack throws the exception Stack::Underflow.
 */

#ifndef STACK_H_
#define STACK_H_

//Include the necessary libraries
#include "StackException.h"
#include <string>
#include <iostream>
using namespace std;

// Create a typedef int
typedef int Item;

// Create a template
template <class Item>

//Create a class Stack
class Stack {
public:
	// Implement the methods
	Stack(unsigned size);
	Stack(const Stack<Item>& original);
	~Stack();
	Stack<Item>& operator=(const Stack<Item>& original);
	bool isEmpty();
	void push(const Item& it);
	bool isFull();
	Item getTop() const;
	Item pop();
	unsigned getSize() const;
	unsigned getCapacity() const;
	void setCapacity(unsigned newCapacity);
	
protected:
	void makeCopyOf(const Stack<Item>& original);
	
private:
	//Implement the methods
	unsigned myCapacity;
	unsigned myTop;
	Item * myArray;
	friend class StackTester;
};

template <class Item>
Stack<Item>::Stack(unsigned size) {
	if (size > 0) {
		myTop = 0;
	    myCapacity = size;
	    myArray = new Item[size];
	}
	else {
		throw StackException("Stack(size)", "size must be positive!");
	}

}

/* copy constructor
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original.
 */
template <class Item>
Stack<Item>::Stack(const Stack<Item>& original) {
	makeCopyOf(original);
}

/* utility method containing code refactored from
 *  the copy constructor and operator=.
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original.
 */
template <class Item>
void Stack<Item>::makeCopyOf(const Stack<Item>& original) {
	myCapacity = original.myCapacity;
	myArray = new Item[myCapacity];

	for (unsigned i = 0; i < myCapacity; i++) {
		myArray[i] = original.myArray[i];
	}
	myTop = original.myTop;
}

/* destructor
 * Postcondition: myCapacity == 0 && myTop == 0
 *             && myArray has been deallocated.
 */
template <class Item>
Stack<Item>::~Stack() {
	delete [] myArray;
	myArray = NULL;
	myCapacity = 0;
	myTop = 0;
}

/* assignment operator
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original
 *              && I have been returned.
 */
template <class Item>
Stack<Item>& Stack<Item>::operator=(const Stack<Item>& original) {
	if (this != &original) {
		delete [] myArray;
		makeCopyOf(original);
	}
	return *this;
}

/* isEmpty() method - checks if the stack is empty
 * @return: true if the stack is empty, false if it is not
 * Postcondition: The stack can be verified if it is empty or not
 */
template <class Item>
bool Stack<Item>::isEmpty() {
	if (myTop == 0) {
		return true;
	}
	else {
		return false;
	}
}

/* push() method - append an item to the stack
 * @param: const Item& it
 * Precondition: Stack must not be full, or else an exception will be thrown
 * Postcondition: an Item will be appended to the stack
 */
template <class Item>
void Stack<Item>::push(const Item& it) {
	if (myTop == myCapacity) {
		throw StackException("push()", "stack is full");
	}
	else {
		myArray[myTop] = it;
		myTop++;
	}
}

/* isFull() method - Checks if the stack is full or not
 * @return: true if the stack is full, false if it is not
 * Postcondition: The stack will be checked for fullness
 */
template <class Item>
bool Stack<Item>::isFull() {
	if (myTop == myCapacity) {
		return true;
	}
	else {
		return false;
	}
}

/* getTop() method - Lets the user look at the top stack item without changing the stack
 * Precondition: The stack must not be empty, or else an exception will be thrown
 * Postcondition: User can look at the top stack item
 */
template <class Item>
Item Stack<Item>::getTop() const {
	if (myTop > 0) {
		return myArray[myTop - 1];
	}
	else {
		throw StackException("getTop()", "stack is empty");
	}
}

/* pop() method - removes and returns the top value from the stack
 * Precondition: stack must not be empty or else an exception will be thrown
 * Postcondition: the top item in the stack will be removed and returned
 */
template <class Item>
Item Stack<Item>::pop() {
	if (myTop == 0) {
		throw StackException("pop()" , "stack is empty");
	}
	else {
		myTop = myTop - 1;
		return myArray[myTop];
	}
}

/*
 * Returns the size of the stack
 */
template <class Item>
unsigned Stack<Item>::getSize() const {
	return myTop;
}

/*
 * Returns the capacity of the stack
 */
template <class Item>
unsigned Stack<Item>::getCapacity() const {
	return myCapacity;
}

/* setCapacity() method - sets the capacity
 * @param: unsigned newCapacity
 * @return: Nothing
 * Precondition: newCapacity > myCapacity
 * Postcondition: the capacity will be set
 */
template <class Item>
void Stack<Item>::setCapacity(unsigned newCapacity) {
	if (newCapacity < myCapacity) {
		throw StackException("setCapacity()", "newCapacity is too small");
	}
	else if (newCapacity > myCapacity) {
		Item* array = new Item[newCapacity];
		for (unsigned x = 0; x < myCapacity; x++) {
			array[x] = myArray[x];
		}
		for (unsigned x = myCapacity; x < newCapacity; x++) {
			array[x] = 0;
		}
		delete [] myArray;
		myArray = array;
		myCapacity = newCapacity;
	}
}

#endif

/* tester.cpp drives the testing of the Queue classes.
 * Joel Adams, for CS 112 at Calvin College.
 */

#include "ArrayQueueTester.h"
#include "LinkedQueueTester.h"
#include "PalindromeDetectorTester.h"
 
 int main() {
 	ArrayQueueTester aqt;
 	aqt.runTests();
 	LinkedQueueTester lqt;
 	lqt.runTests();
 	PalindromeDetectorTester p;
 	p.runTests();
 }
 
 
zdw3@torvalds:~/workspace/cs112/project8$ cd  cd Debug
zdw3@torvalds:~/workspace/cs112/project8/Debug$ ls
ArrayQueueTester.d  LinkedQueue.d  LinkedQueueTester.d	makefile    PalindromeDetector.d  PalindromeDetectorTester.d  project8	  subdir.mk  tester.o
ArrayQueueTester.o  LinkedQueue.o  LinkedQueueTester.o	objects.mk  PalindromeDetector.o  PalindromeDetectorTester.o  sources.mk  tester.d
zdw3@torvalds:~/workspace/cs112/project8/Debug$   make all
make: Nothing to be done for `all'.
zdw3@torvalds:~/workspace/cs112/project8/Debug$ cd ..
zdw3@torvalds:~/workspace/cs112/project8$ .? /Debug?proje      /P project8
Testing class ArrayQueue...
- testing constructor...  1  2  Passed!
- testing append(), getFirst(), getLast() ...  0a  0b  1  2  3  4  5 Passed!
- testing remove()...  0  1  2  3  4a  4b  4c  4d  5 Passed!
- testing copy constructor...  1  2  3 Passed!
- testing assignment...  1  2  3  4  5  6  7 Passed!
All tests passed!

Testing class LinkedQueue...
- testing constructor...  Passed!
- testing append(), getFirst(), getLast(), ...  0a  0b  1  2  3  4 Passed!
- testing remove()...  0  1  2  3  4a  4b  4c  4d  5 Passed!
- testing copy constructor...  1  2 Passed!
- testing assignment...  1  2  3  4  5  6  7 Passed!
All tests passed!

Testing PalindromeDetector class... 
Testing constructors...  Passed! 
Testing isPalindrome method...  1  2  3  4  5  6  7  Passed! 
Testing detectPalindromes method...  Passed! 
All tests passed! 
zdw3@torvalds:~/workspace/cs112/project8$ exit

Script done on Tue 17 Nov 2015 08:38:06 PM EST
